import pygame
from pygame.locals import *
from maze.game import Game


class Block(pygame.sprite.Sprite):
    # noinspection PyShadowingNames
    def __init__(self, coords, width=5, color=(0, 0, 0)):
        pygame.sprite.Sprite.__init__(self)
        self.coords = coords
        self.width = width
        self.color = color
        self.image = pygame.Surface((width, width))
        self.image.fill(color)
        self.rect = self.image.get_rect()
        self.rect.center = coords

    def get_coords(self):
        return self.coords


# noinspection PyShadowingNames,PyShadowingNames,PyShadowingNames
class Canvas:
    def __init__(self, sprite_group,
                 width=Game.side,
                 height=Game.side,
                 x=0,
                 y=0,
                 ):
        self.width = width
        self.height = height
        self.sprite_group = sprite_group
        self.blocks = []
        self.start_point = None
        self.window = pygame.Surface((int(self.width), int(self.height)))
        self.rect = self.window.get_rect()
        self.rect.x = int(x)
        self.rect.y = int(y)

    def clear(self):  # Clears all points
        self.blocks = []
        self.sprite_group.empty()
    def mouse_pos(self):  # Returns altered mouse pos based on canvas location to prevent offset
        mouse_pos = pygame.mouse.get_pos()
        mouse_pos = (int(mouse_pos[0] - self.rect.x), int(mouse_pos[1] - self.rect.y))
        return mouse_pos

    def draw(self, window):  # Draws objects on canvas surface
        self.sprite_group.draw(self.window)
        self.preview_line()
        window.blit(self.window, self.rect)

    def fill(self, color=Game.color):
        self.window.fill(color)

    def surface(self):  # Returns canvas surface
        return self.window

    def block_at_pos(self, coords):  # Returns true if there is a block at a given point
        for block in self.blocks:
            if block.get_coords == coords:
                return True
        return False

    def point_is_valid(self, point):  # Returns if given point is on canvas
        if 0 <= point[0] <= self.width and 0 <= point[1] <= self.height:
            return True
        return False

    @staticmethod
    def min_max(a, b):  # Returns the smaller and larger value of two given values
        if a < b:
            small = a
            large = b
        else:
            small = b
            large = a
        return small, large

    @staticmethod
    def line(start_point, end_point):  # Generates a list of tuples of coordinates of a line between two points
        # Creates aliases for point coordinates
        x1 = start_point[0]
        x2 = end_point[0]
        y1 = start_point[1]
        y2 = end_point[1]
        # Initializes points in a line
        points = []
        # Returns a single point if start point is the same as endpoint
        if start_point == end_point:
            points.append(start_point)
            return points
        # Avoids divide by 0 for veritcal lines, returns vertical line of points
        if x1 == x2:
            low, hi = Canvas.min_max(y1, y2)
            for y in range(low, hi):
                points.append((x1, y))
        # Creates line by iterating through x plane if slope is less than or equal to 1
        elif abs((y1 - y2) / (x1 - x2)) <= 1:
            def f(var):
                return ((y1 - y2) / (x1 - x2)) * (var - x1) + y1
            low, hi = Canvas.min_max(x1, x2)
            for x in range(low, hi):
                points.append((x, f(x)))
        # Creates line by iterating through y plane is slope is greater than 1
        else:
            def f(var):
                return ((x1 - x2) / (y1 - y2)) * (var - y1) + x1
            low, hi = Canvas.min_max(y1, y2)
            for y in range(low, hi):
                points.append((f(y), y))
        # Returns list of tuples with coordinates for points to create
        return points

    def update(self, event):
        # On mouse click, start drawing a line
        if event.type == MOUSEBUTTONDOWN and event.button == 1:
            self.start_point = self.mouse_pos()
        # On mouse lift, finalize line creation and create a line of points
        elif event.type == MOUSEBUTTONUP and event.button == 1:
            start_point = self.start_point
            end_point = self.mouse_pos()
            # Iterates through points generated by line generator and creates a Block object for each point
            for point in Canvas.line(start_point, end_point):
                self.create_block(point)
            # Resets the line
            self.start_point = None

    def preview_line(self, color=(255, 0, 0)):
        if self.start_point is not None:
            pygame.draw.aaline(self.window, color, self.start_point, self.mouse_pos())

    def create_block(self, point):  # Creates a Block object with given coordinates and adds it to sprite group
        if self.point_is_valid(point) and not self.block_at_pos(point):
            block = Block(point)
            self.blocks.append(block)
            self.sprite_group.add(block)
            return True
        return False
